<!-- 
    Project Name: DNCL_Simulator
    Author: Shohei Yamazaki
    Contact: yamazaki-shohei（at）ed.pref.toyama.jp
-->

<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>DNCL Simulator (v2.1.1a)</title>
    <!-- Blockly Library (v10.4.3) - ビジュアルプログラミングUIを提供 -->
    <script src="https://unpkg.com/blockly@10.4.3/blockly.min.js"></script>
    <!-- JS-Interpreter - JavaScriptコードをステップ実行するためのライブラリ -->
    <script src="https://unpkg.com/js-interpreter@latest"></script>
    <style>
        /* CSS変数: アプリケーション全体のデザイン統一のため */
        :root {
            --header-height: 50px;
            --border-color: #ccc;
            --background-light: #eee;
            --background-panel: #fff;
            --text-color: #333;
            --button-bg: #f5f5f5;
            --button-hover-bg: #e0e0e0;
            --status-error-bg: #fbe9e7;
            --status-error-color: #c62828;
            --status-success-bg: #e8f5e9;
            --status-success-color: #2e7d32;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            overflow: hidden;
            /* ウィンドウ全体のスクロールを禁止 */
            font-family: 'Helvetica Neue', Arial, 'Hiragino Kaku Gothic ProN', 'Hiragino Sans', Meiryo, sans-serif;
            color: var(--text-color);
            /* [FIX] タッチ操作による意図しない拡大などを防ぐ */
            touch-action: none;
        }

        /* カスタムスクロールバー */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        ::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #aaa;
        }

        /* ヘッダーセクション */
        #header {
            height: var(--header-height);
            background: var(--background-light);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 15px;
            box-sizing: border-box;
            gap: 10px;
        }

        #header button {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 6px 12px;
            border-radius: 6px;
            border: 1px solid #bbb;
            background: linear-gradient(to bottom, #fff, #e9e9e9);
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
            box-shadow: 0 1px 1px rgba(0, 0, 0, 0.05);
        }

        #header button:hover {
            background: linear-gradient(to bottom, #f5f5f5, #ddd);
            border-color: #999;
        }

        #header button:active {
            background: linear-gradient(to top, #f5f5f5, #ddd);
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        #header button svg {
            width: 16px;
            height: 16px;
        }

        #header button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: linear-gradient(to bottom, #f0f0f0, #ddd);
        }

        #header button:disabled:hover {
            background: linear-gradient(to bottom, #f0f0f0, #ddd);
            border-color: #bbb;
        }

        #header label {
            margin: 0 10px;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
        }

        #runStatusDiv {
            margin-left: auto;
            /* 右寄せにする */
            font-weight: bold;
            padding: 5px 12px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            min-width: 60px;
            text-align: center;
            transition: all 0.3s ease;
        }

        /* 実行状態に応じたスタイル */
        #runStatusDiv.status-error {
            background-color: var(--status-error-bg);
            color: var(--status-error-color);
            border-color: var(--status-error-color);
        }

        #runStatusDiv.status-success {
            background-color: var(--status-success-bg);
            color: var(--status-success-color);
            border-color: var(--status-success-color);
        }

        /* メインコンテナ（Blocklyワークスペースと出力/状態パネル） */
        #mainContainer {
            display: flex;
            height: calc(100% - var(--header-height));
            box-sizing: border-box;
        }

        .pane {
            height: 100%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: var(--background-panel);
        }

        #paneLeft {
            flex: 2;
        }

        /* 左ペインは右の2倍の幅を初期値とする */
        #paneRight {
            flex: 1;
            min-width: 280px;
            display: flex;
            flex-direction: column;
        }

        /* ペインのリサイズ用ハンドル */
        .resizer-v {
            width: 8px;
            background: var(--background-light);
            cursor: col-resize;
            border-left: 1px solid var(--border-color);
            border-right: 1px solid var(--border-color);
            transition: background-color 0.2s;
            /* [FIX] リサイズハンドル自体がタッチイベントを受け取れるように */
            touch-action: none;
        }

        .resizer-v:hover {
            background-color: #ddd;
        }

        .resizer-h {
            height: 8px;
            background: var(--background-light);
            cursor: row-resize;
            border-top: 1px solid var(--border-color);
            border-bottom: 1px solid var(--border-color);
            transition: background-color 0.2s;
            /* [FIX] リサイズハンドル自体がタッチイベントを受け取れるように */
            touch-action: none;
        }

        .resizer-h:hover {
            background-color: #ddd;
        }

        /* 各パネルのコンテンツ部分 */
        #blocklyDiv,
        #outputDiv,
        #stateDiv {
            flex-grow: 1;
            overflow: auto;
        }

        #outputDiv {
            flex-basis: 50%;
        }

        #stateDiv {
            flex-basis: 50%;
        }

        #outputDiv,
        #stateDiv {
            padding: 10px;
            font-family: 'Menlo', 'Monaco', monospace;
        }

        /* パネルのヘッダー */
        .pane-header {
            background-color: #f0f0f0;
            padding: 6px 12px;
            font-weight: 600;
            font-size: 13px;
            border-bottom: 1px solid var(--border-color);
            color: #555;
        }

        /* 内部状態表示のスタイル */
        .var-container {
            margin-bottom: 8px;
            padding: 5px 8px;
            background: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
        }

        .var-title {
            font-weight: bold;
            font-size: 12px;
            margin-bottom: 4px;
            padding-bottom: 2px;
            border-bottom: 1px solid #f0f0f0;
        }

        .array-table,
        .array-box {
            width: 100%;
            border-collapse: collapse;
        }

        .array-table th,
        .array-table td {
            border: 1px solid #ddd;
            padding: 4px;
            text-align: center;
            min-width: 30px;
            height: 30px;
            font-size: 12px;
        }

        .array-table th {
            background-color: #f7f7f7;
        }

        .array-box {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .array-element {
            width: 35px;
            height: 35px;
            background-color: #e9ecef;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #ced4da;
            border-radius: 3px;
            position: relative;
            font-weight: bold;
            font-size: 13px;
        }

        .array-index {
            position: absolute;
            top: -14px;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 10px;
            color: #6c757d;
        }

        .highlight {
            animation: highlight 1.2s ease-out;
        }

        @keyframes highlight {

            /* 値が変更されたときに適用されるアニメーション */
            0%,
            50% {
                background-color: #fff3cd;
                border-color: #f90;
            }

            100% {
                background-color: inherit;
                border-color: inherit;
            }
        }

        /* 関数呼び出し・戻り値のスタイル */
        .function-call {
            background-color: #e8f5ff;
            border-left: 4px solid #4a86e8;
            padding: 5px 8px;
            margin: 5px 0;
        }

        .function-return {
            background-color: #e6ffe6;
            border-left: 4px solid #6aa84f;
            padding: 5px 8px;
            margin: 5px 0;
        }

        .error-output {
            color: #d9534f;
            font-weight: bold;
        }

        /* モーダルウィンドウのスタイル */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            padding: 20px;
            border-radius: 8px;
            max-width: 80vw;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
            margin-bottom: 10px;
        }

        .modal-header h2 {
            margin: 0;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
        }

        .modal-body {
            overflow: auto;
        }

        /* JSコード表示用のスタイル */
        .modal-body#jsCodeDiv {
            background: #2d2d2d;
            color: #dcdcdc;
            padding: 10px;
            font-family: 'Menlo', 'Monaco', monospace;
            white-space: pre-wrap;
            border-radius: 4px;
        }
    </style>
</head>

<body>
    <!-- ============================================== -->
    <!-- ヘッダーエリア: 操作ボタンと設定               -->
    <!-- ============================================== -->
    <div id="header"> <button id="runButton" title="実行 (F9)"><svg viewBox="0 0 24 24">
                <path fill="currentColor" d="M8,5.14V19.14L19,12.14L8,5.14Z" />
            </svg> 実行</button>
        <button id="stepButton" title="ステップ実行 (F10)"><svg viewBox="0 0 24 24">
                <path fill="currentColor" d="M15,18V6H13V18H15M11,18V6H9V18H11M7,18V6H5V18H7Z" />
            </svg> ステップ</button>
        <button id="stepBackButton" title="戻る" disabled style="display: none;"><svg viewBox="0 0 24 24">
                <path fill="currentColor" d="M16,18V6H14V18H16M11,18L3,12L11,6V18M13,6V18H15V6H13Z" />
            </svg> 戻る</button>
        <button id="resetButton" title="リセット"><svg viewBox="0 0 24 24">
                <path fill="currentColor"
                    d="M12,4C14.1,4 16.1,4.8 17.6,6.3C20.7,9.4 20.7,14.5 17.6,17.6C16.1,19.1 14.1,20 12,20C9.9,20 7.9,19.2 6.4,17.6C3.3,14.5 3.3,9.4 6.4,6.3C7.9,4.8 9.9,4 12,4M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z" />
            </svg> リセット</button>
        <button id="exportButton" title="ファイルにエクスポート"><svg viewBox="0 0 24 24">
                <path fill="currentColor" d="M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z" />
            </svg></button>
        <button id="importButton" title="ファイルからインポート"><svg viewBox="0 0 24 24">
                <path fill="currentColor" d="M9,16V10H5L12,3L19,10H15V16H9M5,20V18H19V20H5Z" />
            </svg></button>
        <input type="file" id="importFile" accept=".xml,text/xml,.txt" style="display: none;">
        <button id="showCodeButton">コード表示</button>
        <label for="languageSelector" style="margin-left: 10px; font-size: 14px; display: flex; align-items: center; gap: 5px; cursor: default;">出力言語:</label>
        <select id="languageSelector" style="padding: 5px; border-radius: 4px; border: 1px solid #bbb; font-size: 14px; background-color: white;">
          <option value="JavaScript" selected>JavaScript</option>
          <option value="Python">Python</option>
        </select>
        <label title="ステップ実行（戻り）機能を有効にします（β版）">
            ステップ実行（戻り）β:
            <input type="checkbox" id="enableStepBackCheckbox">
        </label> <label title="配列のインデックスを1から始めるか設定します">
            配列1始まり(1-based-indexing):
            <input type="checkbox" id="oneBasedCheckbox">
        </label>
        <div id="stepCounterDiv" style="font-size: 12px; margin-left: 10px; color: #666;">ステップ: 0</div>
        <div id="runStatusDiv">待機中</div>
    </div>

    <!-- ============================================== -->
    <!-- メインコンテンツエリア                           -->
    <!-- ============================================== -->
    <div id="mainContainer">
        <!-- 左ペイン: Blocklyワークスペース -->
        <div id="paneLeft" class="pane">
            <div class="pane-header">ブロック</div>
            <div id="blocklyDiv"></div>
        </div>
        <!-- 垂直リサイザー -->
        <div id="resizerV" class="resizer-v"></div>
        <!-- 右ペイン: 出力と内部状態 -->
        <div id="paneRight" class="pane">
            <!-- 出力エリア -->
            <div id="outputWrapper" style="display: flex; flex-direction: column; flex-basis: 50%; overflow: hidden;">
                <div class="pane-header">出力</div>
                <div id="outputDiv"></div>
            </div>
            <!-- 水平リサイザー -->
            <div id="resizerH" class="resizer-h"></div>
            <!-- 内部状態エリア -->
            <div id="stateDivWrapper" style="display: flex; flex-direction: column; flex-grow: 1; overflow: hidden;">
                <div class="pane-header">内部状態</div>
                <div id="stateDiv" style="flex-grow: 1; overflow-y: auto;"></div>
            </div>
        </div>
    </div>

    <!-- ============================================== -->
    <!-- モーダルウィンドウ                            -->
    <!-- ============================================== -->
    <!-- 生成コード表示モーダル -->
    <div id="codeModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h2>生成されたコード (JavaScript)</h2>
                <button id="modalCloseButton" class="modal-close">&times;</button>
            </div>
            <div class="modal-body" id="jsCodeDiv"></div>
        </div>
    </div>
    <!-- 実行終了通知モーダル -->
    <div id="executionFinishedModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h2>実行終了</h2>
                <button id="executionFinishedModalCloseButton" class="modal-close">&times;</button>
            </div>
            <div class="modal-body">
                <p>プログラムの最後まで到達しました。</p>
            </div>
        </div>
    </div>


    <!-- β機能警告モーダル -->
    <div id="betaWarningModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h2>警告</h2>
                <button id="betaWarningModalCloseButton" class="modal-close">&times;</button>
            </div>
            <div class="modal-body">
                <p>この機能はβ版です、ステップ実行（戻り）は正しく実行されない可能性があります。</p>
            </div>
        </div>
    </div>


    <!-- ============================================== -->
    <!-- Blocklyツールボックス定義 (XML)                -->
    <!-- ============================================== -->
    <xml id="toolbox" style="display: none">
        <category name="入出力" colour="160">
            <block type="simple_display"></block>
            <block type="display"></block>
            <block type="external_input"></block>
            <block type="display_binary"></block>
        </category>
        <category name="変数と値" colour="230">
            <block type="assignment"></block>
            <block type="variable_access"></block>
            <block type="inc_dec"></block>
            <block type="number_literal"></block>
            <block type="string_literal"></block>
        </category>
        <category name="配列" colour="260">
            <block type="array_assignment_1d"></block>
            <block type="array_assignment_2d"></block>
            <block type="array_assignment_full"></block>
            <block type="array_assignment_full_2d"></block>
            <block type="array_access_1d"></block>
            <block type="array_access_2d"></block>
        </category>
        <category name="計算" colour="230">
            <block type="arithmetic"></block>
            <block type="square"></block>
            <block type="power"></block>
            <block type="random"></block>
        </category>
        <category name="条件と論理" colour="210">
            <block type="if_statement"></block>
            <block type="if_else_statement"></block>
            <block type="comparison"></block>
            <block type="logic_operation_jp"></block>
            <block type="logic_negate_jp"></block>
        </category>
        <category name="繰り返し" colour="120">
            <block type="for_loop"></block>
            <block type="while_loop"></block>
            <block type="do_while_loop"></block>
        </category>
        <category name="関数" custom="PROCEDURE" colour="290"></category>
        <category name="デバッグ" colour="0">
            <block type="breakpoint"></block>
        </category>
    </xml>

    <!-- 起動時に読み込むブロック（空） -->
    <xml id="startBlocks" style="display:none"></xml>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // β機能（ステップバック）関連の要素を取得
            const stepBackButton = document.getElementById('stepBackButton');
            const enableStepBackCheckbox = document.getElementById('enableStepBackCheckbox');
            const betaWarningModal = document.getElementById('betaWarningModal');
            const betaWarningModalCloseButton = document.getElementById('betaWarningModalCloseButton');

            // β機能（ステップバック）有効化チェックボックスの処理
            enableStepBackCheckbox.addEventListener('change', () => {
                if (enableStepBackCheckbox.checked) {
                    stepBackButton.style.display = 'flex';
                    betaWarningModal.style.display = 'flex';
                } else {
                    stepBackButton.style.display = 'none';
                }
            });

            // β機能警告モーダルを閉じる
            betaWarningModalCloseButton.addEventListener('click', () => {
                betaWarningModal.style.display = 'none';
            });

            //======================================================================
            // グローバル変数と定数
            //======================================================================
            let myInterpreter = null;       // JS-Interpreterのインスタンス
            let workspace = null;           // Blocklyのワークスペースインスタンス
            let oneBasedMode = false;       // 配列のインデックスを1から始めるモードか
            let ignoreBreakpoints = false;  // 一括実行時にブレークポイントを無視するか
            let previousDebugVars = {};     // 前回の変数の状態を保持（変更検出用）
            let currentHighlightedBlockId = null; // 現在ハイライトされているブロックID
            const EXECUTION_TIMEOUT_STEPS = 2000000; // 無限ループ防止用の最大実行ステップ数

            // 実行履歴管理用のグローバル変数            
            const executionHistory = {
                snapshots: [],              // 実行状態のスナップショット配列
                currentIndex: -1,           // 現在のスナップショットインデックス
                maxHistorySize: 500,        // 最大履歴保存数
                stepCounter: 0,             // ステップカウンター (ユーザー操作単位)
                interpreterStepCounter: 0   // Interpreter内部のステップカウンター
            };

            // インタプリタ内の変数を監視するためのグローバルオブジェクト
            window.debugVars = {};

            // JavaScriptジェネレータで使う演算子の優先順位
            const ORDER_ATOMIC = 0;
            const ORDER_NONE = 99;
            const ORDER_ASSIGNMENT = 2;
            const ORDER_FUNCTION_CALL = 2;
            const ORDER_MULTIPLICATION = 5;
            const ORDER_DIVISION = 5;
            const ORDER_MODULUS = 5;
            const ORDER_ADDITION = 6;
            const ORDER_SUBTRACTION = 6;
            const ORDER_LOGICAL_NOT = 4;
            const ORDER_LOGICAL_AND = 11;
            const ORDER_LOGICAL_OR = 12;
            const ORDER_RELATIONAL = 8;

            //======================================================================
            // Pythonジェネレータの準備
            //======================================================================
            Blockly.Python = new Blockly.Generator('Python');
            Blockly.Python.ORDER_ATOMIC = 0;
            Blockly.Python.ORDER_MEMBER = 1.1;
            Blockly.Python.ORDER_FUNCTION_CALL = 2;
            Blockly.Python.ORDER_EXPONENTIATION = 3;
            Blockly.Python.ORDER_UNARY_SIGN = 4;
            Blockly.Python.ORDER_MULTIPLICATIVE = 5;
            Blockly.Python.ORDER_ADDITIVE = 6;
            Blockly.Python.ORDER_BITWISE_SHIFT = 7;
            Blockly.Python.ORDER_BITWISE_AND = 8;
            Blockly.Python.ORDER_BITWISE_XOR = 9;
            Blockly.Python.ORDER_BITWISE_OR = 10;
            Blockly.Python.ORDER_RELATIONAL = 11;
            Blockly.Python.ORDER_LOGICAL_NOT = 12;
            Blockly.Python.ORDER_LOGICAL_AND = 13;
            Blockly.Python.ORDER_LOGICAL_OR = 14;
            Blockly.Python.ORDER_CONDITIONAL = 15;
            Blockly.Python.ORDER_ASSIGNMENT = 16;
            Blockly.Python.ORDER_NONE = 99;

            // More complete init/finish/scrub functions are defined below with the other Python generators.

            //======================================================================
            // 実行履歴管理機能
            //======================================================================
            /*
             * 深いオブジェクトのコピーを作成する（循環参照に対応）
             * @param {*} obj コピーするオブジェクト
             * @param {WeakMap} visited 循環参照検出用のマップ
             * @returns {*} コピーされたオブジェクト
             */
            function deepClone(obj, visited = new WeakMap()) {
                if (obj === null || typeof obj !== "object") return obj;
                if (obj instanceof Date) return new Date(obj.getTime());
                if (obj instanceof RegExp) return new RegExp(obj);

                // 循環参照の検出と処理
                if (visited.has(obj)) {
                    return visited.get(obj);
                }

                if (obj instanceof Array) {
                    const clonedArray = [];
                    visited.set(obj, clonedArray);
                    for (let i = 0; i < obj.length; i++) {
                        clonedArray[i] = deepClone(obj[i], visited);
                    }
                    return clonedArray;
                }

                if (typeof obj === "object") {
                    const cloned = Object.create(Object.getPrototypeOf(obj));
                    visited.set(obj, cloned);

                    for (const key in obj) {
                        if (Object.prototype.hasOwnProperty.call(obj, key)) {
                            try {
                                cloned[key] = deepClone(obj[key], visited);
                            } catch (e) {
                                // コピーできないプロパティはスキップ（例：関数など）
                                console.warn(`プロパティ ${key} のクローンに失敗:`, e);
                            }
                        }
                    }

                    return cloned;
                }

                return obj;
            }/**
             * 現在の実行状態のスナップショットを作成する
             * @returns {Object} 実行状態のスナップショット
             */
            function captureExecutionSnapshot() {
                if (!myInterpreter) return;

                const snapshot = {
                    state: deepClone(myInterpreter.stateStack),
                    stepNumber: executionHistory.stepCounter,
                    interpreterStepCount: executionHistory.interpreterStepCounter,
                    highlightedBlockId: currentHighlightedBlockId,
                    outputHtml: document.getElementById('outputDiv').innerHTML,
                    debugVars: deepClone(window.debugVars)
                };

                // インタプリタの詳細な状態を保存
                try {
                    if (myInterpreter.stateStack_) {
                        snapshot.stateStackLength = myInterpreter.stateStack_.length;
                        snapshot.hasState = true;
                        snapshot.isCompleted = myInterpreter.stateStack_.length === 0;

                        // 実行状態のディープコピーを作成
                        if (myInterpreter.stateStack_.length > 0) {
                            snapshot.interpreterState = {
                                stateStack: deepClone(myInterpreter.stateStack_),
                                globalScope: captureInterpreterScope(myInterpreter.global),
                                value: myInterpreter.value,
                                done: myInterpreter.done_
                            };
                        }
                    } else {
                        snapshot.hasState = false;
                        snapshot.isCompleted = true;
                    }

                    // 生成されたJavaScriptコードを保存（再実行用）
                    if (workspace) {
                        snapshot.codeGenerated = Blockly.JavaScript.workspaceToCode(workspace);
                    }

                    // グローバルスコープの変数を保存
                    snapshot.globalScope = captureGlobalScope();
                } catch (e) {
                    console.warn("インタプリタ状態のキャプチャで警告:", e);
                    snapshot.hasState = false;
                    snapshot.isCompleted = false;
                }

                return snapshot;
            }            /**
             * インタプリタのグローバルスコープの状態をキャプチャする
             * @returns {Object} グローバルスコープの状態
             */
            function captureGlobalScope() {
                if (!myInterpreter || !myInterpreter.global) return {};

                const scope = {};
                const globalProps = myInterpreter.global.properties;

                for (const prop in globalProps) {
                    if (globalProps.hasOwnProperty(prop)) {
                        const value = globalProps[prop];
                        try {
                            // プリミティブ値や配列のみを保存
                            const nativeValue = myInterpreter.pseudoToNative(value);
                            if (typeof nativeValue !== 'function') {
                                scope[prop] = nativeValue;
                            }
                        } catch (e) {
                            // 変換できない値はスキップ
                        }
                    }
                }
                return scope;
            }

            /**
             * インタープリターのスコープを詳細にキャプチャする（実行状態復元用）
             * @param {Object} scope キャプチャするスコープオブジェクト
             * @returns {Object} キャプチャされたスコープデータ
             */
            function captureInterpreterScope(scope) {
                if (!scope) return null;

                try {
                    const capturedScope = {
                        properties: {},
                        proto: scope.proto,
                        isObject: scope.isObject,
                        class: scope.class,
                        data: scope.data
                    };

                    // プロパティをディープコピー
                    if (scope.properties) {
                        for (const prop in scope.properties) {
                            if (scope.properties.hasOwnProperty(prop)) {
                                const value = scope.properties[prop];
                                try {
                                    // オブジェクトの参照情報を保持してコピー
                                    capturedScope.properties[prop] = deepClone(value);
                                } catch (e) {
                                    console.warn(`プロパティ ${prop} のキャプチャに失敗:`, e);
                                }
                            }
                        }
                    }

                    return capturedScope;
                } catch (e) {
                    console.warn("スコープキャプチャエラー:", e);
                    return null;
                }
            }

            /**
             * 実行履歴にスナップショットを保存する
             */
            function saveExecutionSnapshot() {
                const snapshot = captureExecutionSnapshot();
                if (!snapshot) return;

                // 現在位置より後の履歴を削除（新しい分岐の開始）
                if (executionHistory.currentIndex < executionHistory.snapshots.length - 1) {
                    executionHistory.snapshots = executionHistory.snapshots.slice(0, executionHistory.currentIndex + 1);
                }

                // 新しいスナップショットを追加
                executionHistory.snapshots.push(snapshot);
                executionHistory.currentIndex = executionHistory.snapshots.length - 1;

                // 履歴サイズの制限
                if (executionHistory.snapshots.length > executionHistory.maxHistorySize) {
                    const removeCount = executionHistory.snapshots.length - executionHistory.maxHistorySize;
                    executionHistory.snapshots.splice(0, removeCount);
                    executionHistory.currentIndex -= removeCount;
                    if (executionHistory.currentIndex < 0) executionHistory.currentIndex = 0;
                }

                // UI更新
                updateStepCounter();
                updateStepBackButton();
            }

        /**
         * 指定されたスナップショットに実行状態を復元する
         * @param {Object} snapshot 復元するスナップショット
         */        function restoreExecutionSnapshot(snapshot) {
                if (!snapshot) return;

                try {
                    window.debugVars = deepClone(snapshot.debugVars);
                    document.getElementById('outputDiv').innerHTML = snapshot.outputHtml;

                    updateStateDisplayVisual();
                    updateStepCounter();
                    updateStepBackButton();

                    const outputDiv = document.getElementById('outputDiv');
                    outputDiv.scrollTop = outputDiv.scrollHeight;

                } catch (e) {
                    console.error("スナップショット復元エラー:", e);
                    displayOutput("実行状態の復元に失敗しました: " + e.message, true);
                }
            }

            /**
             * グローバルスコープの状態を復元する
             * @param {Object} scopeData 復元するスコープデータ
             */
            function restoreGlobalScope(scopeData) {
                if (!myInterpreter || !myInterpreter.global || !scopeData) return;

                const globalProps = myInterpreter.global.properties;

                for (const prop in scopeData) {
                    if (scopeData.hasOwnProperty(prop)) {
                        try {
                            const nativeValue = scopeData[prop];
                            const pseudoValue = myInterpreter.nativeToPseudo(nativeValue);
                            globalProps[prop] = pseudoValue;
                        } catch (e) {
                            console.warn(`変数 ${prop} の復元に失敗:`, e);
                        }
                    }
                }
            }

            /**
             * ステップカウンターの表示を更新する
             */
            function updateStepCounter() {
                const counterDiv = document.getElementById('stepCounterDiv');
                if (counterDiv) {
                    counterDiv.textContent = `ステップ: ${executionHistory.stepCounter}`;
                }
            }

            /**
             * 戻るボタンの有効/無効状態を更新する
             */
            function updateStepBackButton() {
                const backButton = document.getElementById('stepBackButton');
                if (backButton) {
                    backButton.disabled = executionHistory.currentIndex <= 0;
                }
            }            /**
             * 1ステップ前に戻る
             */
            function stepBack() {
                if (executionHistory.currentIndex <= 0) {
                    displayOutput("これ以上戻れません。", false);
                    return;
                }

                executionHistory.currentIndex--;
                const snapshot = executionHistory.snapshots[executionHistory.currentIndex];

                if (snapshot) {
                    try {
                        console.log(`--- Step Back 開始 (index: ${executionHistory.currentIndex}) ---`);
                        console.log("復元するスナップショット:", snapshot);
                        console.log("スナップショットの interpreterStepCount:", snapshot.interpreterStepCount);

                        // 状態を復元
                        restoreInterpreterState(snapshot);
                        restoreExecutionSnapshot(snapshot);

                        // interpreterStepCounter もスナップショットから復元
                        executionHistory.interpreterStepCounter = snapshot.interpreterStepCount || 0;
                        // stepCounter もスナップショットから復元
                        executionHistory.stepCounter = snapshot.stepNumber || 0;
                        console.log(`復元後の interpreterStepCounter: ${executionHistory.interpreterStepCounter}`);
                        console.log(`復元後の stepCounter: ${executionHistory.stepCounter}`);


                        console.log("--- Step Back 完了 ---");

                    } catch (e) {
                        console.error("ステップバックエラー:", e);
                        displayOutput("ステップバック中にエラーが発生しました: " + e.message, true);
                    }
                }
            }            /*
             * インタープリターの実行状態を復元する
             * @param {Object} snapshot 復元するスナップショット
             */
            function restoreInterpreterState(snapshot) {
                console.log("restoreInterpreterState: 開始", { snapshot });
                if (!snapshot.interpreterState || !snapshot.codeGenerated) {
                    console.warn("インタープリター状態の復元に必要なデータが不足しています。フォールバックします。");
                    // ステップ数による復元を試行
                    restoreByStepCount(snapshot);
                    return;
                }

                try {
                    console.log("restoreInterpreterState: 新しいインタープリターを作成し、状態を復元します。");
                    // 新しいインタープリターを作成
                    const newInterpreter = new Interpreter(snapshot.codeGenerated, initInterpreter);

                    // 保存された状態を復元
                    if (snapshot.interpreterState.stateStack) {
                        newInterpreter.stateStack_ = deepClone(snapshot.interpreterState.stateStack);
                    }

                    if (snapshot.interpreterState.globalScope) {
                        restoreInterpreterScope(newInterpreter.global, snapshot.interpreterState.globalScope);
                    }

                    // その他の状態を復元
                    newInterpreter.value = snapshot.interpreterState.value;
                    newInterpreter.done_ = snapshot.interpreterState.done;

                    // インタープリターを設定
                    myInterpreter = newInterpreter;

                    console.log("インタープリター状態の復元が完了しました");

                } catch (e) {
                    console.error("インタープリター状態復元エラー:", e);

                    // フォールバック: ステップ数による復元を試行
                    console.log("フォールバック: ステップ数による復元を試行します");
                    restoreByStepCount(snapshot);
                }
            }

            /*
             * ステップ数による復元を行う（フォールバック方式）
             * @param {Object} snapshot 復元するスナップショット
             */
            function restoreByStepCount(snapshot) {
                console.log("restoreByStepCount: 開始", { snapshot });
                try {
                    // 新しいインタープリターを作成
                    myInterpreter = null;
                    if (!prepareInterpreter()) {
                        console.error("フォールバック復元: インタープリター作成に失敗");
                        return;
                    }
                    // 目標ステップ数まで高速実行
                    const targetSteps = snapshot.interpreterStepCount || 0;
                    console.log(`restoreByStepCount: 目標ステップ数 = ${targetSteps}`);
                    if (targetSteps > 0) {
                        console.log(`フォールバック復元: インタプリタステップ ${targetSteps} まで高速実行中...`);

                        // ブレークポイントを無視して高速実行
                        const originalIgnoreBreakpoints = ignoreBreakpoints;
                        ignoreBreakpoints = true;

                        const restored = fastForwardToStep(targetSteps);

                        ignoreBreakpoints = originalIgnoreBreakpoints;

                        console.log(`fastForwardToStep result: ${restored}, interpreter state: ${myInterpreter ? 'exists' : 'null'}, done: ${myInterpreter ? myInterpreter.done : 'N/A'}`);

                        // fastForwardToStepがfalseを返しても、プログラムが完了していれば成功とみなす
                        if (restored || (myInterpreter && myInterpreter.done)) {
                            console.log(`restoreByStepCount: 成功。現在のステップ数: ${executionHistory.interpreterStepCounter}, 完了状態: ${myInterpreter ? myInterpreter.done : 'N/A'}`);
                        } else {
                            console.error("restoreByStepCount: fastForwardToStep が失敗しました。");
                            myInterpreter = null;
                        }
                    } else {
                        console.log("restoreByStepCount: 目標ステップが0なので、実行はスキップされました。");
                    }

                } catch (e) {
                    console.error("フォールバック復元エラー:", e);
                    myInterpreter = null;
                }
            }

            /**
             * インタープリターのスコープを復元する
             * @param {Object} targetScope 復元先のスコープ
             * @param {Object} sourceScope 復元元のスコープデータ
             */
            function restoreInterpreterScope(targetScope, sourceScope) {
                if (!targetScope || !sourceScope) return;

                try {
                    // プロパティを復元
                    if (sourceScope.properties) {
                        for (const prop in sourceScope.properties) {
                            if (sourceScope.properties.hasOwnProperty(prop)) {
                                targetScope.properties[prop] = deepClone(sourceScope.properties[prop]);
                            }
                        }
                    }

                    // その他の属性を復元
                    if (sourceScope.proto !== undefined) targetScope.proto = sourceScope.proto;
                    if (sourceScope.isObject !== undefined) targetScope.isObject = sourceScope.isObject;
                    if (sourceScope.class !== undefined) targetScope.class = sourceScope.class;
                    if (sourceScope.data !== undefined) targetScope.data = sourceScope.data;

                } catch (e) {
                    console.warn("スコープ復元エラー:", e);
                }
            }

            /**
             * 実行履歴をクリアする
             */
            function clearExecutionHistory() {
                executionHistory.snapshots = [];
                executionHistory.currentIndex = -1;
                executionHistory.stepCounter = 0;
                executionHistory.interpreterStepCounter = 0; // カウンターをリセット
                updateStepCounter();
                updateStepBackButton();
            }

            //======================================================================
            // ユーティリティ関数
            //======================================================================
            /**
             * 外部入力を受け取るためのプロンプトを表示する
             * @param {string} msg プロンプトに表示するメッセージ
             * @returns {string} 入力された値。キャンセルまたは空の場合は "0" を返す。
             */
            function myPrompt(msg) {
                try {
                    const result = window.prompt(msg);
                    return result === null || result.trim() === '' ? "0" : result;
                } catch (e) {
                    console.error("Input error:", e);
                    return "0"; // エラー時も "0" を返す
                }
            }

            /**
             * インタプリタ内の変数の値を `window.debugVars` に記録する
             * @param {string} varName 変数名
             * @param {*} value 値
             */
            window.nativeLog = function (varName, value) {
                window.debugVars[varName] = value;
            };

            /**
             * 出力パネルにテキストを表示する
             * @param {string} text 表示するテキスト
             * @param {boolean} isError エラーメッセージとして表示するか
             * @param {boolean} addNewline 改行を追加するか
             */
            function displayOutput(text, isError = false, addNewline = true) {
                const outputDiv = document.getElementById('outputDiv');
                if (isError) {
                    const line = document.createElement('div');
                    line.className = 'error-output';
                    line.textContent = text;
                    outputDiv.appendChild(line);
                } else {
                    // `text`が`div`要素を含むHTML文字列の場合、そのまま追加
                    if (typeof text === 'string' && text.trim().startsWith('<div')) {
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = text;
                        while (tempDiv.firstChild) {
                            outputDiv.appendChild(tempDiv.firstChild);
                        }
                    } else {
                        outputDiv.appendChild(document.createTextNode(text));
                    }

                    if (addNewline) {
                        outputDiv.appendChild(document.createElement('br'));
                    }
                }
                outputDiv.scrollTop = outputDiv.scrollHeight; // 自動スクロール
            }

            /**
             * 数値を2進数で出力パネルに表示する
             * @param {number} num 変換する数値
             */
            function displayBinary(num) {
                const bin = Number(num).toString(2);
                displayOutput(bin);
            }

            /**
             * ヘッダーの実行ステータスを更新する
             * @param {string} message 表示メッセージ
             * @param {string} statusClass 'status-success' or 'status-error'
             */
            function setRunStatus(message, statusClass = '') {
                const statusDiv = document.getElementById('runStatusDiv');
                statusDiv.textContent = message;
                statusDiv.className = 'runStatusDiv'; // クラスをリセット
                if (statusClass) {
                    statusDiv.classList.add(statusClass);
                }
            }

            //======================================================================
            // 安全な配列アクセス (1-basedインデックス対応)
            //======================================================================
            /**
             * 1次元配列の要素に安全にアクセスする
             * @param {Array} arr 配列
             * @param {number} idx インデックス
             * @returns {*} 配列の要素
             */
            function safeArrayAccess(arr, idx) {
                const nativeArr = myInterpreter ? myInterpreter.pseudoToNative(arr) : arr;
                const originalIdx = idx;
                if (oneBasedMode) { idx = idx - 1; }

                if (!Array.isArray(nativeArr)) {
                    const msg = `エラー: ${nativeArr} は配列ではありません。`;
                    displayOutput(msg, true);
                    throw new Error(msg);
                }
                if (idx < 0 || idx >= nativeArr.length) {
                    const msg = `エラー: 配列の範囲外アクセス (インデックス: ${originalIdx})`;
                    displayOutput(msg, true);
                    throw new Error(msg);
                }
                return nativeArr[idx];
            }

            /**
             * 2次元配列の要素に安全にアクセスする
             * @param {Array<Array>} arr 2次元配列
             * @param {number} i 1次元目のインデックス
             * @param {number} j 2次元目のインデックス
             * @returns {*} 配列の要素
             */
            function safeArrayAccess2d(arr, i, j) {
                const nativeArr = myInterpreter ? myInterpreter.pseudoToNative(arr) : arr;
                const originalI = i, originalJ = j;
                if (oneBasedMode) { i = i - 1; j = j - 1; }

                if (!Array.isArray(nativeArr)) {
                    const msg = `エラー: ${nativeArr} は2次元配列ではありません。`;
                    displayOutput(msg, true);
                    throw new Error(msg);
                }
                if (i < 0 || i >= nativeArr.length) {
                    const msg = `エラー: 2次元配列の1次元目の範囲外 (インデックス: ${originalI})`;
                    displayOutput(msg, true);
                    throw new Error(msg);
                }
                if (!Array.isArray(nativeArr[i])) {
                    const msg = `エラー: ${nativeArr[i]} は配列ではありません。`;
                    displayOutput(msg, true);
                    throw new Error(msg);
                }
                if (j < 0 || j >= nativeArr[i].length) {
                    const msg = `エラー: 2次元配列の2次元目の範囲外 (インデックス: ${originalJ})`;
                    displayOutput(msg, true);
                    throw new Error(msg);
                }
                return nativeArr[i][j];
            }

            //======================================================================
            // Blockly ブロック定義とJavaScriptコード生成
            //======================================================================
            // --- ブロックの見た目を定義 (JSON) ---
            Blockly.defineBlocksWithJsonArray([
                { "type": "assignment", "message0": "%1 = %2", "args0": [{ "type": "field_input", "name": "VAR", "text": "hensu" }, { "type": "input_value", "name": "VALUE" }], "previousStatement": null, "nextStatement": null, "colour": 230, "tooltip": "変数に値を代入する" },
                { "type": "number_literal", "message0": "%1", "args0": [{ "type": "field_number", "name": "NUM", "value": 0 }], "output": "Number", "colour": 230, "tooltip": "数値を入力する" },
                { "type": "string_literal", "message0": "「%1」", "args0": [{ "type": "field_input", "name": "TEXT", "text": "テキスト" }], "output": "String", "colour": 230, "tooltip": "文字列を入力する" },
                { "type": "external_input", "message0": "外部入力 (%1)", "args0": [{ "type": "field_dropdown", "name": "TYPE", "options": [["文字列", "STRING"], ["数値", "NUMBER"]] }], "output": null, "colour": 160, "tooltip": "ユーザーからの入力を受け取る" },
                { "type": "variable_access", "message0": "変数 %1", "args0": [{ "type": "field_input", "name": "VAR", "text": "hensu" }], "output": null, "colour": 230, "tooltip": "変数の値を取得する" },
                { "type": "array_assignment_1d", "message0": "%1 [ %2 ] = %3", "args0": [{ "type": "field_input", "name": "ARRAY", "text": "Hairetsu" }, { "type": "input_value", "name": "INDEX", "check": "Number" }, { "type": "input_value", "name": "VALUE" }], "previousStatement": null, "nextStatement": null, "colour": 260, "tooltip": "1次元配列の要素に値を代入する" },
                { "type": "array_assignment_2d", "message0": "%1 [ %2, %3 ] = %4", "args0": [{ "type": "field_input", "name": "ARRAY", "text": "Gyoretsu" }, { "type": "input_value", "name": "INDEX1", "check": "Number" }, { "type": "input_value", "name": "INDEX2", "check": "Number" }, { "type": "input_value", "name": "VALUE" }], "previousStatement": null, "nextStatement": null, "colour": 260, "tooltip": "2次元配列の要素に値を代入する" },
                { "type": "array_assignment_full", "message0": "%1 = { %2 }", "args0": [{ "type": "field_input", "name": "ARRAY", "text": "Hairetsu" }, { "type": "field_input", "name": "ELEMENTS", "text": "87,45,72,100" }], "previousStatement": null, "nextStatement": null, "colour": 260, "tooltip": "配列全体に値を代入する" },
                { "type": "array_assignment_full_2d", "message0": "%1 = { %2 }", "args0": [{ "type": "field_input", "name": "ARRAY", "text": "Gyoretsu" }, { "type": "field_input", "name": "ELEMENTS", "text": "1,2;3,4" }], "previousStatement": null, "nextStatement": null, "colour": 260, "tooltip": "2次元配列全体に値を代入する（行はセミコロン、要素はカンマ区切り）" },
                { "type": "array_access_1d", "message0": "%1 [ %2 ]", "args0": [{ "type": "field_input", "name": "ARRAY", "text": "Hairetsu" }, { "type": "input_value", "name": "INDEX", "check": "Number" }], "output": null, "colour": 260, "tooltip": "1次元配列の要素を参照する" },
                { "type": "array_access_2d", "message0": "%1 [ %2, %3 ]", "args0": [{ "type": "field_input", "name": "ARRAY", "text": "Gyoretsu" }, { "type": "input_value", "name": "INDEX1", "check": "Number" }, { "type": "input_value", "name": "INDEX2", "check": "Number" }], "output": null, "colour": 260, "tooltip": "2次元配列の要素を参照する" },
                { "type": "arithmetic", "message0": "%1 %2 %3", "args0": [{ "type": "input_value", "name": "A", "check": "Number" }, { "type": "field_dropdown", "name": "OP", "options": [["+", "+"], ["-", "-"], ["×", "*"], ["/", "/"], ["÷", "÷"], ["%", "%"]] }, { "type": "input_value", "name": "B", "check": "Number" }], "inputsInline": true, "output": "Number", "colour": 230, "tooltip": "算術演算" },
                // [FIX] 比較演算子の表示を変更し、インライン表示を明示
                { "type": "comparison", "message0": "%1 %2 %3", "args0": [{ "type": "input_value", "name": "A" }, { "type": "field_dropdown", "name": "OP", "options": [["==", "==="], ["!=", "!=="], [">", ">"], [">=", ">="], ["<", "<"], ["<=", "<="]] }, { "type": "input_value", "name": "B" }], "inputsInline": true, "output": "Boolean", "colour": 210, "tooltip": "比較演算子" },
                // [FIX] 論理演算子にインライン表示を明示
                { "type": "logic_operation_jp", "message0": "%1 %2 %3", "args0": [{ "type": "input_value", "name": "A", "check": "Boolean" }, { "type": "field_dropdown", "name": "OP", "options": [["かつ", "&&"], ["または", "||"]] }, { "type": "input_value", "name": "B", "check": "Boolean" }], "inputsInline": true, "output": "Boolean", "colour": 210, "tooltip": "論理演算子（and/or）" },
                { "type": "logic_negate_jp", "message0": "でない %1", "args0": [{ "type": "input_value", "name": "BOOL", "check": "Boolean" }], "output": "Boolean", "colour": 210, "tooltip": "論理否定" },
                { "type": "if_statement", "message0": "もし %1 ならば\n%2", "args0": [{ "type": "input_value", "name": "CONDITION", "check": "Boolean" }, { "type": "input_statement", "name": "DO" }], "previousStatement": null, "nextStatement": null, "colour": 210, "tooltip": "if文" },
                { "type": "if_else_statement", "message0": "もし %1 ならば\n%2\nそうでなければ\n%3", "args0": [{ "type": "input_value", "name": "CONDITION", "check": "Boolean" }, { "type": "input_statement", "name": "DO0" }, { "type": "input_statement", "name": "ELSE" }], "previousStatement": null, "nextStatement": null, "colour": 210, "tooltip": "if-else文" },
                { "type": "while_loop", "message0": "%1 の間、繰り返す\n%2", "args0": [{ "type": "input_value", "name": "CONDITION", "check": "Boolean" }, { "type": "input_statement", "name": "DO" }], "previousStatement": null, "nextStatement": null, "colour": 120, "tooltip": "whileループ" },
                { "type": "do_while_loop", "message0": "繰り返し\n%1\nを、%2 になるまで実行する", "args0": [{ "type": "input_statement", "name": "DO" }, { "type": "input_value", "name": "CONDITION", "check": "Boolean" }], "previousStatement": null, "nextStatement": null, "colour": 120, "tooltip": "後判定ループ" },
                { "type": "for_loop", "message0": "%1 を %2 から %3 まで %4 ずつ増やしながら、繰り返す\n%5", "args0": [{ "type": "field_input", "name": "VAR", "text": "i" }, { "type": "input_value", "name": "FROM", "check": "Number" }, { "type": "input_value", "name": "TO", "check": "Number" }, { "type": "input_value", "name": "STEP", "check": "Number" }, { "type": "input_statement", "name": "DO" }], "previousStatement": null, "nextStatement": null, "colour": 120, "tooltip": "forループ" },
                { "type": "inc_dec", "message0": "%1 を %2", "args0": [{ "type": "field_input", "name": "VAR", "text": "hensu" }, { "type": "field_dropdown", "name": "OP", "options": [["1 増やす", "+1"], ["1 減らす", "-1"]] }], "previousStatement": null, "nextStatement": null, "colour": 230, "tooltip": "変数のインクリメント/デクリメント" },
                { "type": "square", "message0": "二乗( %1 )", "args0": [{ "type": "input_value", "name": "NUM", "check": "Number" }], "output": "Number", "colour": 230, "tooltip": "二乗を計算する" },
                { "type": "power", "message0": "べき乗( %1, %2 )", "args0": [{ "type": "input_value", "name": "BASE", "check": "Number" }, { "type": "input_value", "name": "EXP", "check": "Number" }], "output": "Number", "colour": 230, "tooltip": "べき乗を計算する" },
                { "type": "random", "message0": "乱数( %1, %2 )", "args0": [{ "type": "input_value", "name": "MIN", "check": "Number" }, { "type": "input_value", "name": "MAX", "check": "Number" }], "output": "Number", "colour": 230, "tooltip": "乱数を生成する" },
                { "type": "display_binary", "message0": "二進で表示する( %1 )", "args0": [{ "type": "input_value", "name": "NUM", "check": "Number" }], "previousStatement": null, "nextStatement": null, "colour": 160, "tooltip": "数値を2進数で表示する" },
                { "type": "simple_display", "message0": "表示する %1 %2", "args0": [{ "type": "input_value", "name": "VALUE" }, { "type": "field_dropdown", "name": "NEWLINE", "options": [["改行あり", "TRUE"], ["改行なし", "FALSE"]] }], "previousStatement": null, "nextStatement": null, "colour": 160, "tooltip": "値を表示する（改行の有無を選択）" },
                { "type": "display", "message0": "表示項目 %1", "args0": [{ "type": "field_dropdown", "name": "NEWLINE", "options": [["改行あり", "TRUE"], ["改行なし", "FALSE"]] }], "previousStatement": true, "nextStatement": true, "colour": 160, "tooltip": "複数の値を連結して表示する", "mutator": "display_mutator" },
                { "type": "breakpoint", "message0": "ブレークポイント %1", "args0": [{ "type": "input_value", "name": "NUMBER", "check": "Number" }], "previousStatement": null, "nextStatement": null, "colour": 0, "tooltip": "指定した番号のブレークポイントで処理を一時停止する" }
            ]);

            // --- 「表示する」ブロックの動的な入力変化 (Mutator) のための定義 ---
            Blockly.Blocks['display_mutator_container'] = {
                init: function () { this.appendDummyInput().appendField("表示項目"); this.appendStatementInput("STACK"); this.setColour(160); this.setTooltip(""); this.contextMenu = false; }
            };
            Blockly.Blocks['display_mutator_item'] = {
                init: function () { this.appendDummyInput().appendField("項目"); this.setPreviousStatement(true); this.setNextStatement(true); this.setColour(160); this.setTooltip(""); this.contextMenu = false; }
            };
            const displayMutator = {
                mutationToDom: function () { const container = document.createElement('mutation'); container.setAttribute('items', this.itemCount_); return container; },
                domToMutation: function (xmlElement) { this.itemCount_ = parseInt(xmlElement.getAttribute('items'), 10) || 0; this.updateShape_(); },
                decompose: function (workspace) { const containerBlock = workspace.newBlock('display_mutator_container'); containerBlock.initSvg(); let connection = containerBlock.getInput('STACK').connection; for (let i = 0; i < this.itemCount_; i++) { const itemBlock = workspace.newBlock('display_mutator_item'); itemBlock.initSvg(); connection.connect(itemBlock.previousConnection); connection = itemBlock.nextConnection; } return containerBlock; },
                compose: function (containerBlock) { let itemBlock = containerBlock.getInputTargetBlock('STACK'); const connections = []; while (itemBlock) { connections.push(itemBlock.valueConnection_); itemBlock = itemBlock.nextConnection && itemBlock.nextConnection.targetBlock(); } for (let i = 0; i < this.itemCount_; i++) { const connection = this.getInput('ADD' + i)?.connection.targetConnection; if (connection && connections.indexOf(connection) == -1) { connection.disconnect(); } } this.itemCount_ = connections.length; this.updateShape_(); for (let i = 0; i < this.itemCount_; i++) { if (connections[i]) { this.getInput('ADD' + i).connection.connect(connections[i]); } } },
                saveConnections: function (containerBlock) { let itemBlock = containerBlock.getInputTargetBlock('STACK'); let i = 0; while (itemBlock) { const input = this.getInput('ADD' + i); itemBlock.valueConnection_ = input && input.connection.targetConnection; i++; itemBlock = itemBlock.nextConnection && itemBlock.nextConnection.targetBlock(); } }
            };
            Blockly.Extensions.registerMutator('display_mutator', displayMutator, function () { this.itemCount_ = 1; this.updateShape_(); }, ['display_mutator_item']);
            Blockly.Blocks['display'] = {
                init: function () { this.jsonInit({ "message0": "表示項目 %1", "args0": [{ "type": "field_dropdown", "name": "NEWLINE", "options": [["改行あり", "TRUE"], ["改行なし", "FALSE"]] }], "previousStatement": true, "nextStatement": true, "colour": 160, "tooltip": "複数の値を連結して表示する", "mutator": "display_mutator" }); },
                updateShape_: function () { for (let i = 0; this.getInput('ADD' + i); i++) { this.removeInput('ADD' + i); } if (this.getInput('END')) this.removeInput('END'); if (this.getInput('EMPTY')) this.removeInput('EMPTY'); if (this.itemCount_ == 0) { this.appendDummyInput('EMPTY'); } else { for (let i = 0; i < this.itemCount_; i++) { const input = this.appendValueInput('ADD' + i); if (i > 0) { input.appendField("と"); } } } }
            };

            // --- ブロックからJavaScriptコードを生成するロジック ---
            Blockly.JavaScript['assignment'] = function (block) { const varName = block.getFieldValue('VAR'); const value = Blockly.JavaScript.valueToCode(block, 'VALUE', ORDER_ASSIGNMENT) || '0'; return `${varName} = ${value};\nnativeLog('${varName}', ${varName});\n`; };
            Blockly.JavaScript['number_literal'] = (block) => [String(block.getFieldValue('NUM')), ORDER_ATOMIC];
            Blockly.JavaScript['string_literal'] = (block) => [JSON.stringify(block.getFieldValue('TEXT')), ORDER_ATOMIC];
            Blockly.JavaScript['external_input'] = function (block) { const type = block.getFieldValue('TYPE'); const code = "myPrompt('外部からの入力')"; if (type === 'NUMBER') { return [`Number(${code})`, ORDER_FUNCTION_CALL]; } else { return [`${code}`, ORDER_FUNCTION_CALL]; } };
            Blockly.JavaScript['variable_access'] = (block) => [block.getFieldValue('VAR'), ORDER_ATOMIC];
            Blockly.JavaScript['array_assignment_1d'] = function (block) { const arr = block.getFieldValue('ARRAY'); let idx = Blockly.JavaScript.valueToCode(block, 'INDEX', ORDER_NONE) || '0'; const val = Blockly.JavaScript.valueToCode(block, 'VALUE', ORDER_ASSIGNMENT) || '0'; let code = `${arr}[${oneBasedMode ? `(${idx} - 1)` : idx}] = ${val};\n`; code += `nativeLog('${arr}', ${arr});\n`; return code; };
            Blockly.JavaScript['array_assignment_2d'] = function (block) { const arr = block.getFieldValue('ARRAY'); let i = Blockly.JavaScript.valueToCode(block, 'INDEX1', ORDER_NONE) || '0'; let j = Blockly.JavaScript.valueToCode(block, 'INDEX2', ORDER_NONE) || '0'; const val = Blockly.JavaScript.valueToCode(block, 'VALUE', ORDER_ASSIGNMENT) || '0'; const index1 = oneBasedMode ? `(${i} - 1)` : i; const index2 = oneBasedMode ? `(${j} - 1)` : j; let code = `${arr}[${index1}][${index2}] = ${val};\n`; code += `nativeLog('${arr}', ${arr});\n`; return code; };
            Blockly.JavaScript['array_assignment_full'] = function (block) { const arr = block.getFieldValue('ARRAY'); const elements = block.getFieldValue('ELEMENTS'); const splitted = elements.replace(/[{}]/g, '').split(',').map(s => { const trimmed = s.trim(); return isNaN(Number(trimmed)) ? JSON.stringify(trimmed) : Number(trimmed); }); return `${arr} = [${splitted.join(', ')}];\nnativeLog('${arr}', ${arr});\n`; };
            Blockly.JavaScript['array_assignment_full_2d'] = function (block) { const arr = block.getFieldValue('ARRAY'); const elementsText = block.getFieldValue('ELEMENTS') || ''; const rows = elementsText.split(';').map(rowText => { const elements = rowText.split(',').map(e => { const trimmed = e.trim(); return isNaN(Number(trimmed)) ? JSON.stringify(trimmed) : Number(trimmed); }); return `[${elements.join(',')}]`; }); return `${arr} = [${rows.join(',')}];\nnativeLog('${arr}', ${arr});\n`; };
            Blockly.JavaScript['array_access_1d'] = (block) => [`safeArrayAccess(${block.getFieldValue('ARRAY')}, ${Blockly.JavaScript.valueToCode(block, 'INDEX', ORDER_NONE) || '0'})`, ORDER_FUNCTION_CALL];
            Blockly.JavaScript['array_access_2d'] = (block) => [`safeArrayAccess2d(${block.getFieldValue('ARRAY')}, ${Blockly.JavaScript.valueToCode(block, 'INDEX1', ORDER_NONE) || '0'}, ${Blockly.JavaScript.valueToCode(block, 'INDEX2', ORDER_NONE) || '0'})`, ORDER_FUNCTION_CALL];
            Blockly.JavaScript['arithmetic'] = function (block) { if (block.getFieldValue('OP') === '÷') { const a = Blockly.JavaScript.valueToCode(block, 'A', ORDER_NONE) || '0'; const b = Blockly.JavaScript.valueToCode(block, 'B', ORDER_NONE) || '0'; return [`Math.floor(${a} / ${b})`, ORDER_FUNCTION_CALL]; } const OPERATORS = { '+': [' + ', ORDER_ADDITION], '-': [' - ', ORDER_SUBTRACTION], '*': [' * ', ORDER_MULTIPLICATION], '/': [' / ', ORDER_DIVISION], '%': [' % ', ORDER_MODULUS], }; const tuple = OPERATORS[block.getFieldValue('OP')]; const operator = tuple[0]; const order = tuple[1]; const argument0 = Blockly.JavaScript.valueToCode(block, 'A', order) || '0'; const argument1 = Blockly.JavaScript.valueToCode(block, 'B', order) || '0'; const code = argument0 + operator + argument1; return [code, order]; };
            Blockly.JavaScript['comparison'] = (block) => [`(${Blockly.JavaScript.valueToCode(block, 'A', ORDER_RELATIONAL) || '0'} ${block.getFieldValue('OP')} ${Blockly.JavaScript.valueToCode(block, 'B', ORDER_RELATIONAL) || '0'})`, ORDER_RELATIONAL];
            Blockly.JavaScript['logic_operation_jp'] = (block) => { const op = block.getFieldValue('OP'); const order = op === '&&' ? ORDER_LOGICAL_AND : ORDER_LOGICAL_OR; return [`(${Blockly.JavaScript.valueToCode(block, 'A', order) || 'false'} ${op} ${Blockly.JavaScript.valueToCode(block, 'B', order) || 'false'})`, order]; };
            Blockly.JavaScript['logic_negate_jp'] = (block) => [`(!${Blockly.JavaScript.valueToCode(block, 'BOOL', ORDER_LOGICAL_NOT) || 'false'})`, ORDER_LOGICAL_NOT];
            Blockly.JavaScript['if_statement'] = (block) => `if (${Blockly.JavaScript.valueToCode(block, 'CONDITION', ORDER_NONE) || 'false'}) {\n${Blockly.JavaScript.statementToCode(block, 'DO')}}\n`;
            Blockly.JavaScript['if_else_statement'] = (block) => `if (${Blockly.JavaScript.valueToCode(block, 'CONDITION', ORDER_NONE) || 'false'}) {\n${Blockly.JavaScript.statementToCode(block, 'DO0')}} else {\n${Blockly.JavaScript.statementToCode(block, 'ELSE')}}\n`;
            Blockly.JavaScript['while_loop'] = (block) => `while (${Blockly.JavaScript.valueToCode(block, 'CONDITION', ORDER_NONE) || 'false'}) {\n${Blockly.JavaScript.statementToCode(block, 'DO')}}\n`;
            Blockly.JavaScript['do_while_loop'] = (block) => `do {\n${Blockly.JavaScript.statementToCode(block, 'DO')}} while (!(${Blockly.JavaScript.valueToCode(block, 'CONDITION', ORDER_NONE) || 'false'}));\n`;
            Blockly.JavaScript['for_loop'] = function (block) { const varName = block.getFieldValue('VAR'); const fromVal = Blockly.JavaScript.valueToCode(block, 'FROM', ORDER_ASSIGNMENT) || '0'; const toVal = Blockly.JavaScript.valueToCode(block, 'TO', ORDER_RELATIONAL) || '0'; const stepVal = Blockly.JavaScript.valueToCode(block, 'STEP', ORDER_ASSIGNMENT) || '1'; if (Number(stepVal) === 0) { throw new Error("「くりかえし」ブロックの「ずつ増やす」の値に0は指定できません。"); } const branch = Blockly.JavaScript.statementToCode(block, 'DO'); let operator = '<='; const stepBlock = block.getInputTargetBlock('STEP'); if (stepBlock && stepBlock.type === 'number_literal') { const stepNum = Number(stepBlock.getFieldValue('NUM')); if (stepNum < 0) { operator = '>='; } } else if (stepVal.trim().startsWith('-')) { operator = '>='; } const loopCode = `for (${varName} = ${fromVal}; ${varName} ${operator} ${toVal}; ${varName} += ${stepVal}) {\n  nativeLog('${varName}', ${varName});\n${branch}}\n`; const finalLog = `nativeLog('${varName}', ${varName});\n`; return loopCode + finalLog; };
            Blockly.JavaScript['inc_dec'] = (block) => { const varName = block.getFieldValue('VAR'); const op = block.getFieldValue('OP') === '+1' ? '++' : '--'; return `${varName}${op};\nnativeLog('${varName}', ${varName});\n`; };
            Blockly.JavaScript['square'] = (block) => [`(${Blockly.JavaScript.valueToCode(block, 'NUM', ORDER_NONE) || '0'} * ${Blockly.JavaScript.valueToCode(block, 'NUM', ORDER_NONE) || '0'})`, ORDER_MULTIPLICATION];
            Blockly.JavaScript['power'] = (block) => [`Math.pow(${Blockly.JavaScript.valueToCode(block, 'BASE', ORDER_NONE) || '0'}, ${Blockly.JavaScript.valueToCode(block, 'EXP', ORDER_NONE) || '0'})`, ORDER_FUNCTION_CALL];
            Blockly.JavaScript['random'] = (block) => [`(Math.floor(Math.random() * ((${Blockly.JavaScript.valueToCode(block, 'MAX', ORDER_NONE) || '0'} - ${Blockly.JavaScript.valueToCode(block, 'MIN', ORDER_NONE) || '0'}) + 1)) + ${Blockly.JavaScript.valueToCode(block, 'MIN', ORDER_NONE) || '0'})`, ORDER_FUNCTION_CALL];
            Blockly.JavaScript['display_binary'] = (block) => `displayBinary(${Blockly.JavaScript.valueToCode(block, 'NUM', ORDER_NONE) || '0'});\n`;
            Blockly.JavaScript['simple_display'] = (block) => { const value = Blockly.JavaScript.valueToCode(block, 'VALUE', ORDER_NONE) || '""'; const newline = block.getFieldValue('NEWLINE') === 'TRUE'; return `displayOutput(${value}, false, ${newline});\n`; };
            Blockly.JavaScript['display'] = function (block) { const parts = []; for (let i = 0; i < block.itemCount_; i++) { parts.push(Blockly.JavaScript.valueToCode(block, 'ADD' + i, ORDER_NONE) || '""'); } const text = `[${parts.join(', ')}].join('')`; const newline = block.getFieldValue('NEWLINE') === 'TRUE'; return `displayOutput(${text}, false, ${newline});\n`; };
            Blockly.JavaScript['breakpoint'] = function (block) { const number = Blockly.JavaScript.valueToCode(block, 'NUMBER', ORDER_NONE) || 'null'; return `checkBreakpoint(${number});\n`; };

            Blockly.Python['procedures_defreturn'] = function(block) {
                const funcName = Blockly.Python.variableDB_.getName(block.getFieldValue('NAME'), 'PROCEDURE');
                let xfix1 = '';
                if (Blockly.Python.STATEMENT_PREFIX) {
                    xfix1 += Blockly.Python.injectId(Blockly.Python.STATEMENT_PREFIX, block);
                }
                if (Blockly.Python.STATEMENT_SUFFIX) {
                    xfix1 += Blockly.Python.injectId(Blockly.Python.STATEMENT_SUFFIX, block);
                }
                if (xfix1) {
                    xfix1 = Blockly.Python.prefixLines(xfix1, Blockly.Python.INDENT);
                }
                let loopTrap = '';
                if (Blockly.Python.INFINITE_LOOP_TRAP) {
                    loopTrap = Blockly.Python.prefixLines(Blockly.Python.injectId(Blockly.Python.INFINITE_LOOP_TRAP, block), Blockly.Python.INDENT);
                }
                const branch = Blockly.Python.statementToCode(block, 'STACK');
                let returnValue = Blockly.Python.valueToCode(block, 'RETURN', Blockly.Python.ORDER_NONE) || '';
                let xfix2 = '';
                if (branch && returnValue) {
                    xfix2 = Blockly.Python.prefixLines(Blockly.Python.injectId(Blockly.Python.STATEMENT_SUFFIX, block), Blockly.Python.INDENT);
                }
                if (returnValue) {
                    returnValue = Blockly.Python.INDENT + 'return ' + returnValue + '\n';
                } else if (!branch) {
                    returnValue = Blockly.Python.PASS;
                }
                const args = [];
                const variables = block.getVars();
                for (let i = 0; i < variables.length; i++) {
                    args[i] = Blockly.Python.variableDB_.getName(variables[i], 'VARIABLE');
                }
                let code = 'def ' + funcName + '(' + args.join(', ') + '):\n' + xfix1 + loopTrap + branch + xfix2 + returnValue;
                code = Blockly.Python.scrub_(block, code);
                Blockly.Python.definitions_['%' + funcName] = code;
                return null;
            };

            Blockly.Python['procedures_defnoreturn'] = Blockly.Python['procedures_defreturn'];

            Blockly.Python['procedures_callreturn'] = function(block) {
                const funcName = Blockly.Python.variableDB_.getName(block.getFieldValue('NAME'), 'PROCEDURE');
                const args = [];
                const variables = block.getVars();
                for (let i = 0; i < variables.length; i++) {
                    args[i] = Blockly.Python.valueToCode(block, 'ARG' + i, Blockly.Python.ORDER_NONE) || 'None';
                }
                const code = funcName + '(' + args.join(', ') + ')';
                return [code, Blockly.Python.ORDER_FUNCTION_CALL];
            };

            Blockly.Python['procedures_callnoreturn'] = function(block) {
                const funcName = Blockly.Python.variableDB_.getName(block.getFieldValue('NAME'), 'PROCEDURE');
                const args = [];
                const variables = block.getVars();
                for (let i = 0; i < variables.length; i++) {
                    args[i] = Blockly.Python.valueToCode(block, 'ARG' + i, Blockly.Python.ORDER_NONE) || 'None';
                }
                const code = funcName + '(' + args.join(', ') + ')\n';
                return code;
            };

            Blockly.Python['procedures_ifreturn'] = function(block) {
                let condition = Blockly.Python.valueToCode(block, 'CONDITION', Blockly.Python.ORDER_NONE) || 'False';
                let code = 'if ' + condition + ':\n';
                if (block.hasReturnValue_) {
                    const value = Blockly.Python.valueToCode(block, 'VALUE', Blockly.Python.ORDER_NONE) || 'None';
                    code += Blockly.Python.INDENT + 'return ' + value + '\n';
                } else {
                    code += Blockly.Python.INDENT + 'return\n';
                }
                return code;
            };

            // (このセクションはPythonジェネレータの初期化時に上書きされるため、ここではプレースホルダとしておく)
            Blockly.Python.init = function(workspace) {
                Blockly.Python.PASS = this.INDENT + 'pass\n';

                // Create a string of reserved words for the Blockly.Names constructor.
                const reservedWordsString = 'and,as,assert,break,class,continue,def,del,elif,else,except,finally,for,from,global,if,import,in,is,lambda,nonlocal,not,or,pass,raise,return,try,while,with,yield,print,int,float,str,list,dict,set,tuple,input,range';

                // Initialize the variable DB with the reserved words string.
                if (!Blockly.Python.variableDB_) {
                    Blockly.Python.variableDB_ = new Blockly.Names(reservedWordsString);
                } else {
                    Blockly.Python.variableDB_.reset();
                }
                Blockly.Python.variableDB_.setVariableMap(workspace.getVariableMap());

                // For other uses, it can be useful to have the reserved words as a set.
                Blockly.Python.reservedWords_ = new Set(reservedWordsString.split(','));

                // Initialize imports and definitions
                Blockly.Python.imports_ = {};
                Blockly.Python.definitions_ = {};
            };

            Blockly.Python.finish = function(code) {
                // インポート文とヘルパー関数をコードの先頭に追加
                const imports = Object.values(Blockly.Python.imports_).join('\n');
                const definitions = Object.values(Blockly.Python.definitions_).join('\n\n');
                // definitionsとcodeの間に十分な改行を入れる
                const finalCode = (imports ? imports + '\n\n' : '') +
                                  (definitions ? definitions + '\n\n' : '') +
                                  code;
                // クリア
                Blockly.Python.imports_ = {};
                Blockly.Python.definitions_ = {};
                return finalCode;
            };

            Blockly.Python.scrub_ = function(block, code, opt_thisOnly) {
                const nextBlock = block.nextConnection && block.nextConnection.targetBlock();
                const nextCode = opt_thisOnly ? '' : this.blockToCode(nextBlock);
                return code + nextCode;
            };

            Blockly.Python.provideFunction_ = function(name, codeLines) {
                const placeholder = '%FUNCTION_NAME_PLACEHOLDER%';
                let functionName = Blockly.Python.variableDB_.getName(name, 'PROCEDURE');
                if (!Blockly.Python.definitions_[name]) {
                    functionName = Blockly.Python.variableDB_.getDistinctName(name, 'PROCEDURE');
                    let code = codeLines.join('\n').replace(new RegExp(placeholder, 'g'), functionName);
                    Blockly.Python.definitions_[name] = code;
                }
                return functionName;
            };

            Blockly.Python['assignment'] = function(block) {
                const varName = Blockly.Python.variableDB_.getName(block.getFieldValue('VAR'), 'VARIABLE');
                const value = Blockly.Python.valueToCode(block, 'VALUE', Blockly.Python.ORDER_ASSIGNMENT) || '0';
                return `${varName} = ${value}\n`;
            };

            Blockly.Python['number_literal'] = (block) => [String(block.getFieldValue('NUM')), Blockly.Python.ORDER_ATOMIC];
            Blockly.Python['string_literal'] = (block) => [`'${block.getFieldValue('TEXT')}'`, Blockly.Python.ORDER_ATOMIC];

            Blockly.Python['external_input'] = function(block) {
                const type = block.getFieldValue('TYPE');
                const prompt = `input('外部からの入力')`;
                if (type === 'NUMBER') {
                    return [`int(${prompt})`, Blockly.Python.ORDER_FUNCTION_CALL];
                }
                return [prompt, Blockly.Python.ORDER_FUNCTION_CALL];
            };

            Blockly.Python['variable_access'] = (block) => [Blockly.Python.variableDB_.getName(block.getFieldValue('VAR'), 'VARIABLE'), Blockly.Python.ORDER_ATOMIC];

            Blockly.Python['array_assignment_1d'] = function(block) {
                const arr = Blockly.Python.variableDB_.getName(block.getFieldValue('ARRAY'), 'VARIABLE');
                let idx = Blockly.Python.valueToCode(block, 'INDEX', Blockly.Python.ORDER_NONE) || '0';
                const val = Blockly.Python.valueToCode(block, 'VALUE', Blockly.Python.ORDER_ASSIGNMENT) || '0';
                return `${arr}[${oneBasedMode ? `int(${idx}) - 1` : `int(${idx})`}] = ${val}\n`;
            };

            Blockly.Python['array_assignment_2d'] = function (block) {
                const arr = Blockly.Python.variableDB_.getName(block.getFieldValue('ARRAY'), 'VARIABLE');
                let i = Blockly.Python.valueToCode(block, 'INDEX1', Blockly.Python.ORDER_NONE) || '0';
                let j = Blockly.Python.valueToCode(block, 'INDEX2', Blockly.Python.ORDER_NONE) || '0';
                const val = Blockly.Python.valueToCode(block, 'VALUE', Blockly.Python.ORDER_ASSIGNMENT) || '0';
                const i_access = oneBasedMode ? `int(${i}) - 1` : `int(${i})`;
                const j_access = oneBasedMode ? `int(${j}) - 1` : `int(${j})`;
                return `${arr}[${i_access}][${j_access}] = ${val}\n`;
            };

            Blockly.Python['array_assignment_full'] = function(block) {
                const arr = Blockly.Python.variableDB_.getName(block.getFieldValue('ARRAY'), 'VARIABLE');
                const elements = block.getFieldValue('ELEMENTS');
                const splitted = elements.split(',').map(s => {
                    const trimmed = s.trim();
                    return isNaN(Number(trimmed)) || trimmed === '' ? `'${trimmed}'` : Number(trimmed);
                });
                return `${arr} = [${splitted.join(', ')}]\n`;
            };

            Blockly.Python['array_assignment_full_2d'] = function (block) {
                const arr = Blockly.Python.variableDB_.getName(block.getFieldValue('ARRAY'), 'VARIABLE');
                const elementsText = block.getFieldValue('ELEMENTS') || '';
                const rows = elementsText.split(';').map(rowText => `[${rowText.trim()}]`);
                return `${arr} = [${rows.join(', ')}]\n`;
            };

            Blockly.Python['array_access_1d'] = function(block) {
                const arr = Blockly.Python.variableDB_.getName(block.getFieldValue('ARRAY'), 'VARIABLE');
                let idx = Blockly.Python.valueToCode(block, 'INDEX', Blockly.Python.ORDER_NONE) || '0';
                const idx_access = oneBasedMode ? `int(${idx}) - 1` : `int(${idx})`;
                return [`${arr}[${idx_access}]`, Blockly.Python.ORDER_MEMBER];
            };

            Blockly.Python['array_access_2d'] = function(block) {
                const arr = Blockly.Python.variableDB_.getName(block.getFieldValue('ARRAY'), 'VARIABLE');
                let i = Blockly.Python.valueToCode(block, 'INDEX1', Blockly.Python.ORDER_NONE) || '0';
                let j = Blockly.Python.valueToCode(block, 'INDEX2', Blockly.Python.ORDER_NONE) || '0';
                const i_access = oneBasedMode ? `int(${i}) - 1` : `int(${i})`;
                const j_access = oneBasedMode ? `int(${j}) - 1` : `int(${j})`;
                return [`${arr}[${i_access}][${j_access}]`, Blockly.Python.ORDER_MEMBER];
            };

            Blockly.Python['arithmetic'] = function(block) {
                const OPERATORS = {
                    '+': [' + ', Blockly.Python.ORDER_ADDITIVE],
                    '-': [' - ', Blockly.Python.ORDER_ADDITIVE],
                    '×': [' * ', Blockly.Python.ORDER_MULTIPLICATIVE],
                    '*': [' * ', Blockly.Python.ORDER_MULTIPLICATIVE],
                    '/': [' / ', Blockly.Python.ORDER_MULTIPLICATIVE],
                    '÷': [' // ', Blockly.Python.ORDER_MULTIPLICATIVE],
                    '%': [' % ', Blockly.Python.ORDER_MULTIPLICATIVE],
                };
                const tuple = OPERATORS[block.getFieldValue('OP')];
                const operator = tuple[0];
                const order = tuple[1];
                const argument0 = Blockly.Python.valueToCode(block, 'A', order) || '0';
                const argument1 = Blockly.Python.valueToCode(block, 'B', order) || '0';
                return [argument0 + operator + argument1, order];
            };

            Blockly.Python['comparison'] = function(block) {
                const OPERATORS = {
                    '===': ' == ', '==': ' == ',
                    '!==': ' != ', '!=': ' != ',
                    '<': ' < ', '<=': ' <= ',
                    '>': ' > ', '>=': ' >= '
                };
                const op = OPERATORS[block.getFieldValue('OP')];
                const argument0 = Blockly.Python.valueToCode(block, 'A', Blockly.Python.ORDER_RELATIONAL) || '0';
                const argument1 = Blockly.Python.valueToCode(block, 'B', Blockly.Python.ORDER_RELATIONAL) || '0';
                return [`${argument0}${op}${argument1}`, Blockly.Python.ORDER_RELATIONAL];
            };

            Blockly.Python['logic_operation_jp'] = function(block) {
                const OPERATORS = { '&&': 'and', '||': 'or' };
                const op = OPERATORS[block.getFieldValue('OP')];
                const order = (op === 'and') ? Blockly.Python.ORDER_LOGICAL_AND : Blockly.Python.ORDER_LOGICAL_OR;
                const argument0 = Blockly.Python.valueToCode(block, 'A', order) || 'False';
                const argument1 = Blockly.Python.valueToCode(block, 'B', order) || 'False';
                return [`${argument0} ${op} ${argument1}`, order];
            };

            Blockly.Python['logic_negate_jp'] = (block) => [`not ${Blockly.Python.valueToCode(block, 'BOOL', Blockly.Python.ORDER_LOGICAL_NOT) || 'False'}`, Blockly.Python.ORDER_LOGICAL_NOT];

            Blockly.Python['if_statement'] = function(block) {
                const condition = Blockly.Python.valueToCode(block, 'CONDITION', Blockly.Python.ORDER_NONE) || 'False';
                const branch = Blockly.Python.statementToCode(block, 'DO') || Blockly.Python.PASS;
                return `if ${condition}:\n${branch}`;
            };

            Blockly.Python['if_else_statement'] = function(block) {
                const condition = Blockly.Python.valueToCode(block, 'CONDITION', Blockly.Python.ORDER_NONE) || 'False';
                const branch_do = Blockly.Python.statementToCode(block, 'DO0') || Blockly.Python.PASS;
                const branch_else = Blockly.Python.statementToCode(block, 'ELSE') || Blockly.Python.PASS;
                return `if ${condition}:\n${branch_do}else:\n${branch_else}`;
            };

            Blockly.Python['while_loop'] = function(block) {
                const condition = Blockly.Python.valueToCode(block, 'CONDITION', Blockly.Python.ORDER_NONE) || 'False';
                const branch = Blockly.Python.statementToCode(block, 'DO') || Blockly.Python.PASS;
                return `while ${condition}:\n${branch}`;
            };

            Blockly.Python['do_while_loop'] = function(block) {
                const branch = Blockly.Python.statementToCode(block, 'DO') || Blockly.Python.PASS;
                const condition = Blockly.Python.valueToCode(block, 'CONDITION', Blockly.Python.ORDER_LOGICAL_NOT) || 'False';
                return `while not (${condition}):\n${branch}`;
            };

            Blockly.Python['for_loop'] = function(block) {
                const varName = Blockly.Python.variableDB_.getName(block.getFieldValue('VAR'), 'VARIABLE');
                const fromVal = Blockly.Python.valueToCode(block, 'FROM', Blockly.Python.ORDER_NONE) || '0';
                const toVal = Blockly.Python.valueToCode(block, 'TO', Blockly.Python.ORDER_NONE) || '0';
                const stepVal = Blockly.Python.valueToCode(block, 'STEP', Blockly.Python.ORDER_NONE) || '1';
                const branch = Blockly.Python.statementToCode(block, 'DO') || Blockly.Python.PASS;

                // The end value of the range is inclusive, so we need to adjust it by 1
                // depending on the step direction.
                const endExpr = `int(${toVal}) + (1 if int(${stepVal}) > 0 else -1)`;

                return `for ${varName} in range(int(${fromVal}), ${endExpr}, int(${stepVal})):\n${branch}`;
            };

            Blockly.Python['inc_dec'] = function(block) {
                const varName = Blockly.Python.variableDB_.getName(block.getFieldValue('VAR'), 'VARIABLE');
                const op = block.getFieldValue('OP') === '+1' ? '+=' : '-=';
                return `${varName} ${op} 1\n`;
            };

            Blockly.Python['square'] = (block) => [`(${Blockly.Python.valueToCode(block, 'NUM', Blockly.Python.ORDER_EXPONENTIATION) || '0'}) ** 2`, Blockly.Python.ORDER_EXPONENTIATION];
            Blockly.Python['power'] = (block) => [`(${Blockly.Python.valueToCode(block, 'BASE', Blockly.Python.ORDER_EXPONENTIATION) || '0'}) ** (${Blockly.Python.valueToCode(block, 'EXP', Blockly.Python.ORDER_EXPONENTIATION) || '0'})`, Blockly.Python.ORDER_EXPONENTIATION];

            Blockly.Python['random'] = function(block) {
                Blockly.Python.imports_['random'] = 'import random';
                const min = Blockly.Python.valueToCode(block, 'MIN', Blockly.Python.ORDER_NONE) || '0';
                const max = Blockly.Python.valueToCode(block, 'MAX', Blockly.Python.ORDER_NONE) || '0';
                return [`random.randint(int(${min}), int(${max}))`, Blockly.Python.ORDER_FUNCTION_CALL];
            };

            Blockly.Python['display_binary'] = (block) => `print(bin(int(${Blockly.Python.valueToCode(block, 'NUM', Blockly.Python.ORDER_NONE) || '0'})))\n`;

            Blockly.Python['simple_display'] = function(block) {
                const value = Blockly.Python.valueToCode(block, 'VALUE', Blockly.Python.ORDER_NONE) || '""';
                const newline = block.getFieldValue('NEWLINE') === 'TRUE';
                return `print(${value}${newline ? '' : ', end=""'})\n`;
            };

            Blockly.Python['display'] = function(block) {
                const parts = [];
                for (let i = 0; i < block.itemCount_; i++) {
                    parts.push(Blockly.Python.valueToCode(block, 'ADD' + i, Blockly.Python.ORDER_NONE) || '""');
                }
                const string_parts = parts.map(p => `str(${p})`);
                const text = string_parts.join(' + ') || '""';
                const newline = block.getFieldValue('NEWLINE') === 'TRUE';
                return `print(${text}${newline ? '' : ', end=""'})\n`;
            };

            Blockly.Python['breakpoint'] = (block) => '# Breakpoint is not supported in Python export.\npass\n';

            //======================================================================
            // インタプリタの初期化と拡張
            //======================================================================
            /**
             * JS-Interpreterインスタンスを初期化し、カスタム関数を登録する
             * @param {Interpreter} interpreter JS-Interpreterのインスタンス
             * @param {Object} globalObject インタプリタのグローバルスコープ
             */
            function initInterpreter(interpreter, globalObject) {
                // JS-Interpreter内で使えるネイティブ関数を作成するヘルパー

                function createNative(func) { return interpreter.createNativeFunction(func); }

                // displayOutput, myPromptなどをインタプリタのグローバルのグローバルスコープに追加
                interpreter.setProperty(globalObject, 'displayOutput', createNative((text, isError, addNewline) => displayOutput(text !== null && text !== undefined ? text.toString() : "", isError, addNewline)));
                interpreter.setProperty(globalObject, 'displayBinary', createNative(num => displayBinary(num || 0)));
                interpreter.setProperty(globalObject, 'safeArrayAccess', createNative((arr, idx) => safeArrayAccess(arr, idx)));
                interpreter.setProperty(globalObject, 'safeArrayAccess2d', createNative((arr, i, j) => safeArrayAccess2d(arr, i, j)));
                interpreter.setProperty(globalObject, 'nativeLog', createNative((varName, value) => window.nativeLog(varName, interpreter.pseudoToNative(value))));
                interpreter.setProperty(globalObject, 'myPrompt', createNative(msg => myPrompt(interpreter.pseudoToNative(msg))));

                // ブレークポイント処理用の関数
                interpreter.setProperty(globalObject, 'checkBreakpoint', createNative((number) => {
                    if (!ignoreBreakpoints) {
                        myInterpreter.paused_ = true;
                        myInterpreter.breakpointNumber = number;
                    }
                }));

                // 関数の呼び出しと戻り値をフックして出力パネルに表示
                const originalFuncCall = interpreter.functionCall;
                interpreter.functionCall = function (func, funcThis, args) {
                    let funcName = (func.node && func.node.id) ? func.node.id.name : "匿名関数";
                    const argVals = args ? args.map(a => interpreter.pseudoToNative(a)) : [];
                    displayOutput(`<div class='function-call'>関数呼び出し: ${funcName}(${argVals.join(", ")})</div>`, false, false);
                    const result = originalFuncCall.call(this, func, funcThis, args);
                    if (result !== undefined && func.node.type !== 'FunctionDeclaration') {
                        const returnVal = interpreter.pseudoToNative(result);
                        displayOutput(`<div class='function-return'>関数 ${funcName} の戻り値: ${returnVal}</div>`, false, false);
                    }
                    return result;
                };
            }

            //======================================================================
            // 内部状態の可視化
            //======================================================================
            /**
             * `window.debugVars`の内容を「内部状態」パネルに描画する
             */
            function updateStateDisplayVisual() {
                const stateDiv = document.getElementById('stateDiv');
                stateDiv.innerHTML = "";
                let currentCopy = JSON.parse(JSON.stringify(window.debugVars));

                for (const key in window.debugVars) {
                    const container = document.createElement('div');
                    container.className = "var-container";

                    const title = document.createElement('div');
                    title.className = "var-title";
                    title.textContent = key;
                    container.appendChild(title);

                    const value = window.debugVars[key];
                    const oldValue = previousDebugVars[key];

                    if (Array.isArray(value)) {
                        // 2次元配列の場合：テーブルで表示
                        if (Array.isArray(value[0])) {
                            const table = document.createElement('table');
                            table.className = 'array-table';
                            const thead = table.createTHead().insertRow();
                            thead.insertCell(); // 左上の空セル
                            for (let j = 0; j < value[0].length; j++) {
                                const th = document.createElement('th');
                                th.textContent = oneBasedMode ? j + 1 : j;
                                thead.appendChild(th);
                            }
                            const tbody = table.createTBody();
                            for (let i = 0; i < value.length; i++) {
                                const tr = tbody.insertRow();
                                const th = document.createElement('th');
                                th.textContent = oneBasedMode ? i + 1 : i;
                                tr.appendChild(th);
                                for (let j = 0; j < value[i].length; j++) {
                                    const td = tr.insertCell();
                                    td.textContent = value[i][j];
                                    // 値が変更されていたらハイライト
                                    if (!oldValue || !Array.isArray(oldValue) || !oldValue[i] || value[i][j] !== oldValue[i][j]) {
                                        td.classList.add('highlight');
                                    }
                                }
                            }
                            container.appendChild(table);
                        } else { // 1次元配列の場合：ボックスで表示
                            const arrayBox = document.createElement('div');
                            arrayBox.className = "array-box";
                            for (let i = 0; i < value.length; i++) {
                                const elemDiv = document.createElement('div');
                                elemDiv.className = "array-element";
                                elemDiv.innerHTML = `<div class="array-index">${oneBasedMode ? i + 1 : i}</div>${value[i]}`;
                                // 値が変更されていたらハイライト
                                if (!oldValue || !Array.isArray(oldValue) || value[i] !== oldValue[i]) {
                                    elemDiv.classList.add('highlight');
                                }
                                arrayBox.appendChild(elemDiv);
                            }
                            container.appendChild(arrayBox);
                        }
                    } else { // 通常の変数の場合
                        const textDiv = document.createElement('div');
                        textDiv.textContent = value;
                        // 値が変更されていたらハイライト
                        if (value !== oldValue) {
                            textDiv.classList.add('highlight');
                        }
                        container.appendChild(textDiv);
                    }
                    stateDiv.appendChild(container);
                }
                previousDebugVars = currentCopy; // 現在の状態を保存
            }            //======================================================================
            // プログラム実行制御
            //======================================================================
            /**
             * 実行状態をリセットする
             */
            function resetExecution() {
                if (myInterpreter) myInterpreter = null;
                document.getElementById('outputDiv').innerHTML = "";
                document.getElementById('stateDiv').innerHTML = "";
                window.debugVars = {};
                previousDebugVars = {};
                clearExecutionHistory(); // 実行履歴もクリア
                setRunStatus("待機中");
            }            /*
             * インタープリターを準備する。コード生成時のエラーも捕捉する。
             * @returns {boolean} 準備に成功したか
             */
            function prepareInterpreter() {
                // 既にインタープリターが存在する場合（復元された状態など）はそのまま使用
                if (myInterpreter) return true;

                try {
                    // ワークスペース上の全ての変数を取得し、`var`宣言を生成
                    const allVariables = workspace.getAllVariables();
                    const varNames = allVariables.map(v => v.name);
                    const declarationString = varNames.length > 0 ? `var ${[...new Set(varNames)].join(', ')};\n` : '';

                    // ブロックからJavaScriptコードを生成（ここでエラーがスローされる可能性がある）
                    const blockCode = Blockly.JavaScript.workspaceToCode(workspace);
                    const finalCode = declarationString + blockCode;

                    myInterpreter = new Interpreter(finalCode, initInterpreter);
                    window.myInterpreter = myInterpreter; // デバッグ用にグローバルに公開

                    return true;
                } catch (e) {
                    setRunStatus("コード生成エラー", "status-error");
                    displayOutput("コード生成エラー: " + e.message, true);
                    return false;
                }
            }

            /*
             * インタープリターを指定ステップ数まで高速実行する（復元用）
             * @param {number} targetSteps 目標ステップ数
             * @returns {boolean} 復元に成功したか
             */
            function fastForwardToStep(targetSteps) {
                if (!myInterpreter || targetSteps <= 0) return true;

                let stepCount = 0;
                const maxSteps = targetSteps * 2; // 安全のため最大実行数を制限

                try {
                    while (stepCount < targetSteps && stepCount < maxSteps) {
                        // タイムアウトチェック
                        if (stepCount++ > EXECUTION_TIMEOUT_STEPS) {
                            displayOutput("実行がタイムアウトしました。無限ループの可能性があります。", true);
                            setRunStatus("タイムアウト", "status-error");
                            myInterpreter = null;
                            return;
                        }
                        try {
                            executionHistory.interpreterStepCounter++;
                            if (!myInterpreter.step()) {
                                // プログラムが終了した
                                break;
                            }
                        } catch (e) {
                            console.error("高速実行中にエラー:", e);
                            displayOutput("実行エラー: " + e.message, true);
                            setRunStatus("エラー発生", "status-error");
                            myInterpreter = null;
                            return;
                        }
                    }

                    return stepCount >= targetSteps;
                } catch (e) {
                    console.error("高速実行中にエラー:", e);
                    return false;
                }
            }/**
             * 次のブレークポイントまで、またはプログラム終了まで実行する（ステップ実行）
             */
            function stepCode() {
                // インタープリターが既に存在する場合（復元された状態）はそのまま使用
                // 存在しない場合は新しく準備
                if (!myInterpreter && !prepareInterpreter()) {
                    return;
                }

                ignoreBreakpoints = false; // ブレークポイントを有効にする

                // 初回実行時は開始時点のスナップショットを保存
                if (executionHistory.snapshots.length === 0) {
                    executionHistory.stepCounter = 0;
                    saveExecutionSnapshot();
                }

                setRunStatus("ステップ実行中...");

                let stepCount = 0;
                let finished = false;
                while (true) {
                    // タイムアウトチェック
                    if (stepCount++ > EXECUTION_TIMEOUT_STEPS) {
                        displayOutput("実行がタイムアウトしました。無限ループの可能性があります。", true);
                        setRunStatus("タイムアウト", "status-error");
                        myInterpreter = null;
                        return;
                    }
                    try {
                        executionHistory.interpreterStepCounter++;
                        if (!myInterpreter.step()) {
                            finished = true; // プログラムが終了した
                            break;
                        }
                        if (myInterpreter.paused_) {
                            break; // ブレークポイントで一時停止した
                        }
                    } catch (e) {
                        displayOutput("実行エラー: " + e.message, true);
                        setRunStatus("エラー発生", "status-error");
                        myInterpreter = null;
                        return;
                    }
                }

                // ステップカウンターを増加してスナップショットを保存
                executionHistory.stepCounter++;
                saveExecutionSnapshot();

                updateStateDisplayVisual(); // 状態を更新

                if (finished) {
                    setRunStatus("プログラム終了", "status-success");
                    document.getElementById('executionFinishedModal').style.display = 'flex';
                } else if (myInterpreter && myInterpreter.paused_) {
                    const bpNum = myInterpreter.breakpointNumber;
                    myInterpreter.paused_ = false; // 次のステップ実行のためにpausedフラグをリセット
                    myInterpreter.breakpointNumber = null;
                    const statusText = (bpNum !== null && bpNum !== undefined) ? `ブレークポイント ${bpNum}` : 'ブレークポイント';
                    setRunStatus(statusText);
                } else {
                    setRunStatus(`ステップ ${executionHistory.stepCounter}`);
                }
            }

            /**
             * プログラムを最後まで一括実行する
             */
            function runAll() {
                // 実行前に状態をリセット
                myInterpreter = null;
                document.getElementById('outputDiv').innerHTML = "";
                document.getElementById('stateDiv').innerHTML = "";
                window.debugVars = {};
                previousDebugVars = {};
                // 実行履歴はクリアしない

                if (!prepareInterpreter()) return;

                ignoreBreakpoints = true; // ブレークポイントを無効にする
                setRunStatus("一括実行中...");

                let stepCount = 0;
                const BATCH_SIZE = 2000; // UIが固まらないよう、一度に実行するステップ数

                const runner = () => {
                    try {
                        for (let i = 0; i < BATCH_SIZE; i++) {
                            // タイムアウトチェック
                            if (stepCount++ > EXECUTION_TIMEOUT_STEPS) {
                                displayOutput("実行がタイムアウトしました。無限ループの可能性があります。", true);
                                setRunStatus("タイムアウト", "status-error");
                                myInterpreter = null;
                                return;
                            }

                            executionHistory.interpreterStepCounter++;
                            if (!myInterpreter || !myInterpreter.step()) {
                                // プログラムが終了した
                                updateStateDisplayVisual();
                                setRunStatus("プログラム終了", "status-success");
                                myInterpreter = null;
                                return;
                            }
                        }
                        // BATCH_SIZEステップ実行したら、次のバッチをスケジュール
                        setTimeout(runner, 0);
                    } catch (e) {
                        displayOutput("実行エラー: " + e.message, true);
                        updateStateDisplayVisual();
                        setRunStatus("エラー発生", "status-error");
                        myInterpreter = null;
                    }
                };
                runner(); // 実行開始
            }

            //======================================================================
            // UI（ペインのリサイズ）ロジック
            //======================================================================
            /**
             * [FIX] タッチイベントに対応したリサイズハンドルの機能を設定する
             * @param {HTMLElement} resizerEl リサイザー要素
             * @param {boolean} isVertical 垂直リサイザーか
             */
            function setupResizer(resizerEl, isVertical = true) {
                let startX = 0, startY = 0;
                let prevSiblingSize = 0;

                const dragStartHandler = function (e) {
                    // ドラッグ中のテキスト選択などを防ぐ
                    e.preventDefault();

                    // イベントタイプによって座標の取得方法を切り替える
                    const clientX = e.clientX ?? (e.touches && e.touches[0].clientX);
                    const clientY = e.clientY ?? (e.touches && e.touches[0].clientY);

                    startX = clientX;
                    startY = clientY;

                    const prevSibling = resizerEl.previousElementSibling;
                    if (isVertical) {
                        prevSiblingSize = prevSibling.getBoundingClientRect().width;
                    } else {
                        prevSiblingSize = prevSibling.getBoundingClientRect().height;
                    }

                    // mousemoveとtouchmoveの両方のイベントリスナーを追加
                    document.addEventListener('mousemove', dragMoveHandler);
                    document.addEventListener('touchmove', dragMoveHandler, { passive: false });

                    // mouseupとtouchendの両方のイベントリスナーを追加
                    document.addEventListener('mouseup', dragEndHandler);
                    document.addEventListener('touchend', dragEndHandler);
                };

                const dragMoveHandler = function (e) {
                    // touchmoveイベントでpreventDefaultを呼び出し、スクロールを防止
                    if (e.type === 'touchmove') {
                        e.preventDefault();
                    }

                    const clientX = e.clientX ?? (e.touches && e.touches[0].clientX);
                    const clientY = e.clientY ?? (e.touches && e.touches[0].clientY);

                    const prevSibling = resizerEl.previousElementSibling;
                    if (isVertical) {
                        const dx = clientX - startX;
                        const newWidth = prevSiblingSize + dx;
                        if (newWidth > 100) { // 最小幅制限
                            prevSibling.style.flex = `0 0 ${newWidth}px`;
                        }
                    } else {
                        const dy = clientY - startY;
                        const newHeight = prevSiblingSize + dy;
                        if (newHeight > 50) { // 最小高さ制限
                            prevSibling.style.flex = `0 0 ${newHeight}px`;
                        }
                    }
                    // Blocklyワークスペースのサイズを更新するためにリサイズイベントを発火
                    window.dispatchEvent(new Event('resize'));
                };

                const dragEndHandler = function () {
                    // すべてのイベントリスナーを解除
                    document.removeEventListener('mousemove', dragMoveHandler);
                    document.removeEventListener('touchmove', dragMoveHandler);
                    document.removeEventListener('mouseup', dragEndHandler);
                    document.removeEventListener('touchend', dragEndHandler);
                };

                // mousedownとtouchstartの両イベントでドラッグを開始
                resizerEl.addEventListener('mousedown', dragStartHandler);
                resizerEl.addEventListener('touchstart', dragStartHandler, { passive: false });
            }


            //======================================================================
            // インポート/エクスポート機能
            //======================================================================
            function exportBlocks() {
                try {
                    const xml = Blockly.Xml.workspaceToDom(workspace);
                    const xmlText = Blockly.Xml.domToPrettyText(xml);
                    const a = document.createElement('a');
                    a.href = 'data:text/xml;charset=utf-8,' + encodeURIComponent(xmlText);
                    a.download = 'dncl_program.xml';
                    a.click();
                } catch (e) {
                    alert("エクスポート失敗: " + e.message);
                    console.error(e);
                }
            }

            function importBlocks() {
                document.getElementById('importFile').click();
            }

            function loadBlocksFromFile(file) {
                if (!file) return;
                const reader = new FileReader();
                reader.onload = function (e) {
                    const xmlText = e.target.result;
                    try {
                        const xml = Blockly.utils.xml.textToDom(xmlText);
                        workspace.clear();
                        Blockly.Xml.domToWorkspace(xml, workspace);
                    } catch (e) {
                        alert("インポート失敗: ファイルが不正です。\n" + e.message);
                        console.error(e);
                    }
                };
                reader.readAsText(file);
            }

            //======================================================================
            // アプリケーションの初期化とイベントリスナー設定
            //======================================================================
            // Blocklyワークスペースを注入（生成）
            workspace = Blockly.inject('blocklyDiv', {
                toolbox: document.getElementById('toolbox'),
                scrollbars: true,
                zoom: { controls: true, wheel: true }
            });
            window.workspace = workspace; // Make workspace global for Playwright tests
            // --- ボタンのイベントリスナー ---
            document.getElementById('runButton').addEventListener('click', runAll);
            document.getElementById('stepButton').addEventListener('click', stepCode);
            document.getElementById('stepBackButton').addEventListener('click', stepBack);
            document.getElementById('resetButton').addEventListener('click', resetExecution);
            document.getElementById('exportButton').addEventListener('click', exportBlocks);
            document.getElementById('importButton').addEventListener('click', importBlocks);
            document.getElementById('importFile').addEventListener('change', (e) => loadBlocksFromFile(e.target.files[0]));
            document.getElementById('oneBasedCheckbox').addEventListener('change', (e) => { oneBasedMode = e.target.checked; });

            // --- 言語セレクターのイベントリスナー ---
            const langSelector = document.getElementById('languageSelector');
            const runButton = document.getElementById('runButton');
            const stepButton = document.getElementById('stepButton');
            langSelector.addEventListener('change', (e) => {
                const isPython = e.target.value === 'Python';
                runButton.disabled = isPython;
                stepButton.disabled = isPython;
                stepBackButton.disabled = isPython;

                if (isPython) {
                    setRunStatus("Pythonモード (実行不可)", "status-error");
                    displayOutput("Pythonモードが選択されました。このモードではプログラムの実行はできません。", false);
                } else {
                    setRunStatus("待機中");
                }
            });

            // --- コード表示モーダルの設定 ---
            const codeModal = document.getElementById('codeModal');
            document.getElementById('showCodeButton').addEventListener('click', () => {
                const language = document.getElementById('languageSelector').value;
                const modalTitle = document.querySelector('#codeModal .modal-header h2');
                let finalCode = '';

                try {
                    if (language === 'Python') {
                        modalTitle.textContent = '生成されたコード (Python)';
                        finalCode = Blockly.Python.workspaceToCode(workspace);
                    } else { // JavaScript
                        modalTitle.textContent = '生成されたコード (JavaScript)';
                        const allVariables = workspace.getAllVariables();
                        const varNames = allVariables.map(v => v.name);
                        const declarationString = varNames.length > 0 ? `var ${[...new Set(varNames)].join(', ')};\n` : '';
                        const blockCode = Blockly.JavaScript.workspaceToCode(workspace);
                        finalCode = declarationString + blockCode;
                    }
                    document.getElementById('jsCodeDiv').textContent = finalCode;
                    codeModal.style.display = 'flex';
                } catch (e) {
                    console.error("Code generation failed:", e);
                    setRunStatus("コード生成エラー", "status-error");
                    displayOutput("コード生成エラー: " + e.message, true);
                    document.getElementById('jsCodeDiv').textContent = "コードの生成に失敗しました。\n" + e.message;
                    codeModal.style.display = 'flex';
                }
            });
            document.getElementById('modalCloseButton').addEventListener('click', () => { codeModal.style.display = 'none'; });
            codeModal.addEventListener('click', (e) => { if (e.target === codeModal) { codeModal.style.display = 'none'; } }); // 背景クリックで閉じる

            // --- 実行終了モーダルの設定 ---
            const executionFinishedModal = document.getElementById('executionFinishedModal');
            const executionFinishedModalCloseButton = document.getElementById('executionFinishedModalCloseButton');
            executionFinishedModalCloseButton.addEventListener('click', () => { executionFinishedModal.style.display = 'none'; });
            executionFinishedModal.addEventListener('click', (e) => { if (e.target === executionFinishedModal) { executionFinishedModal.style.display = 'none'; } });

            // --- リサイザーの初期化 ---
            setupResizer(document.getElementById('resizerV'), true);
            setupResizer(document.getElementById('resizerH'), false);

            // --- ウィンドウリサイズ時の処理 ---
            window.addEventListener('resize', () => Blockly.svgResize(workspace));

            // --- ページを離れる前の確認 ---
            window.addEventListener('beforeunload', (event) => {
                if (workspace.getAllBlocks(false).length > 0) {
                    event.preventDefault();
                    event.returnValue = ''; // 標準的なブラウザで確認ダイアログを表示するために必要
                }
            });

            // --- 初期ブロックの読み込み ---
            try {
                const startXml = document.getElementById('startBlocks');
                if (startXml.innerHTML.trim()) {
                    Blockly.Xml.domToWorkspace(startXml, workspace);
                }
            } catch (e) {
                console.error("Error loading start blocks:", e);
                displayOutput("起動時のブロック読み込みエラー: " + e.message, true);
            }

            // --- ワークスペースを中央にスクロール ---
            workspace.scrollCenter();
        });
    </script>
</body>

</html>